#!/usr/bin/env python3
"""
This script populates a .csv file, generated by ADP code,
with a column listing RPMs - one per Package Path.
Those RPMs are fetched from the container environment
for each docker image.
"""

import subprocess
import argparse
import re
import pandas as pd

def expand_multiple_paths(path_sep_dict):
    """
    Returns input dictionary after splitting elements based on
       a specific list of file extensions.

    Parameters:
       path_sep_dict (dictionary): the dictionary which elements
       are going to be splitted.

    Returns:
       path_sep_dict (dictionary): the resulting dictionary after the split.
    """

    ext_list_esc = [r'\.ear', r'\.war', r'\.jar']
    ext_list = [sub.replace('\\', '') for sub in ext_list_esc]
    ext_list_esc_join = '|'.join(ext_list_esc)
    for values in path_sep_dict.values():
        for i, value in enumerate(values):
            path_ext_list = re.split(f'({ext_list_esc_join})', value)
            for ii, j in enumerate(path_ext_list):
                if j in ext_list:
                    path_ext_list[ii-1:ii+1] = [''.join(path_ext_list[ii-1:ii+1])]
            if '' in path_ext_list:
                path_ext_list.remove('')
            if len(path_ext_list) > 1:
                print(f'Found concatenated package paths: {path_ext_list}')
                path_ext_list_sep = re.split('(&)', '&'.join(path_ext_list))
                values[i:i+1] = values[i:i]+path_ext_list_sep+values[i+1:i+1]
    return path_sep_dict

def get_rpms(image_path, df_package_path):
    """
    Returns a temporary Dataframe including RPMs column gathered by
       executing docker command.

       Example of Dataframe:
       Package Path                       Index    RPM
       ericsson/.../jboss-client.jar      0        EXTReap7_CXPXXXXXXX:1.1.1

    Parameters:
       image_path (string): Docker Image Armdocker path and version
       df_package_path (dataframe): the dataframe listing package paths.

    Returns:
       (dataframe): the resulting dataframe composed by
       package paths and corresponding RPMs.

       path_sep_dict (dictionary): Key: Indexes,
       Values: Package paths with separator
    """

    # Initialize empty Lists to create partial Dataframe
    package_path_list = []
    index_list = []
    rpm_list = []
    path_sep_dict = {}

    idx = df_package_path.index.to_list() # return List of indexes for Package Paths Dataframe

    for idy, package_paths in enumerate(df_package_path):
        sep_list_join = ''.join(sep_list)
        if any(substring in package_paths for substring in sep_list):
            path_sep_dict[idx[idy]] = re.split(f'([{sep_list_join}])', package_paths)
        else:
            path_sep_dict[idx[idy]] = [package_paths]

        path_sep_dict = expand_multiple_paths(path_sep_dict)
        package_path = re.split(f'[{sep_list_join}]',
                                ''.join(list(path_sep_dict.values())[idy]))
        package_path_list.extend(package_path)
        index_list.extend([idx[idy]] * len(package_path)) # keep information about original indexing

    # Run Docker to get RPMs list for a specific Docker Image and list of package paths
    docker_run_command = """var=$(docker run --rm --entrypoint /bin/bash {} -c \
            'for i in $(rpm -qa); do rpm -q --queryformat \
            \"[%{{FILENAMES}} %{{=NAME}}:%{{=VERSION}}\n]\" \"${{i}}\"; done' | sort); \
            for str in {}; do if [ \"${{str}}\" = \"None\" ]; then echo \"None\"; \
            else echo \"${{var}}\" | grep -oP \"(?<=${{str}}).*\" \
            || echo \"None\"; fi; echo \"\n\"; done""".format(image_path,
                                                              ' '.join(package_path_list))
    print('Running Docker to get RPMs list...')
    res = ""
    try:
        with subprocess.Popen(docker_run_command, shell=True,
                              stdout=subprocess.PIPE, universal_newlines=True) as proc:
            res = proc.stdout.read()
    except OSError: # handle 'Argument list too long' error
        package_path_list_first = package_path_list[:len(package_path_list)//2]
        package_path_list_second = package_path_list[len(package_path_list)//2:]
        for path_list in [package_path_list_first, package_path_list_second]:
            docker_run_command = """var=$(docker run --rm --entrypoint /bin/bash {} -c \
                    'for i in $(rpm -qa); do rpm -q --queryformat \
                    \"[%{{FILENAMES}} %{{=NAME}}:%{{=VERSION}}\n]\" \"${{i}}\"; done' | sort); \
                    for str in {}; do if [ \"${{str}}\" = \"None\" ]; then echo \"None\"; \
                    else echo \"${{var}}\" | grep -oP \"(?<=${{str}}).*\" \
                    || echo \"None\"; fi; echo \"\n\"; done""".format(image_path,
                                                                    ' '.join(path_list))
            with subprocess.Popen(docker_run_command, shell=True,
                                  stdout=subprocess.PIPE, universal_newlines=True) as proc:
                res = res + proc.stdout.read()
    rpm_list.extend(res.split('\n\n\n'))

    # clean RPMs list
    rpm_list = [re.sub(r"\n|^\s", "", s) for s in rpm_list]
    rpm_list.remove('')

    dict = {'Package Path': package_path_list, 'Index': index_list, 'RPM': rpm_list}
    return path_sep_dict, pd.DataFrame(dict)

sep_list = ['|', '#', '&'] # '|' and '#' are standard separators for multiple package paths

def main(input, output):
    """
    MAIN function
    """
    df_vuln = pd.read_csv(input, keep_default_na=False) # don't include the default NaN values

    for image_path in df_vuln['Image Path'].unique(): # return unique values for Docker Images
        print(f'Processing Docker Image: {image_path}')
        df_package_path = df_vuln[df_vuln['Image Path']==image_path]['Package Paths']
        path_sep_dict, df_rpm = get_rpms(image_path, df_package_path)

        # loop through indexes and populate Rpm Package column for the original Dataframe
        sep_list_orig = sep_list.copy()
        sep_list_orig.remove('&')
        sep_list_orig_join = ''.join(sep_list_orig)
        for index in df_rpm['Index'].unique():
            count = 0
            package_paths_separator = []
            rpm_list_indexed = df_rpm[df_rpm['Index']==index]['RPM'].to_list()
            # restore original separators
            for idx, x in enumerate(path_sep_dict[index]):
                if x not in sep_list:
                    package_paths_separator.insert(idx, rpm_list_indexed[count])
                    count += 1
                else:
                    package_paths_separator.insert(idx, x)
                    continue
            package_paths_separator_orig = re.split(
                f'([{sep_list_orig_join}])', ''.join(package_paths_separator))
            for i, path in enumerate(package_paths_separator_orig):
                if '&' in path:
                    first_non_empty_value = next((
                        item for item in reversed(path.split('&'))
                        if item != 'None'), 'None') # traverse paths list in reverse order
                    package_paths_separator_orig[i] = first_non_empty_value
            df_vuln.loc[index, 'Rpm Package'] = ''.join(package_paths_separator_orig)

        # clean docker environment
        docker_cleanup_command = f'docker rmi {image_path}'
        print(f'Removing Docker Image: {image_path}')
        with subprocess.Popen(docker_cleanup_command, shell=True,
                              stdout=subprocess.PIPE, universal_newlines=True) as proc:
            print(proc.stdout.read())
    df_vuln.to_csv(output, index=False)

# main
if __name__ == "__main__":
    parser = argparse.ArgumentParser(
                        prog = 'python -u ./rpmVAenrichment.py',
                        description = '''
                        This script populates a .csv file, generated by ADP code, with a column
                        listing RPMs - one per Package Path. Those RPMs are fetched from
                        the container environment for each docker image.''')
    parser.add_argument('input', type = argparse.FileType('r'),
                        help = 'Input .CSV Filename') # input filename (CSV)
    parser.add_argument('output', type = argparse.FileType('w'),
                        help = 'Output .CSV Filename',) # output filename (enriched CSV)
    args = parser.parse_args()
    main(args.input, args.output)